[package]
name = "mettatron"
version = "0.2.0"
edition = "2021"
authors = ["F1R3FLY.io"]
description = "MeTTaTron - MeTTa language evaluator with lazy evaluation and pattern matching"
license = "Apache-2.0"
repository = "https://github.com/F1R3FLY-io/MeTTa-Compiler"
keywords = ["metta", "evaluator", "lisp", "pattern-matching"]
categories = ["compilers", "parser-implementations"]

[lib]
name = "mettatron"
path = "src/lib.rs"
crate-type = ["rlib", "cdylib"]

[[bin]]
name = "mettatron"
path = "src/main.rs"

[[bench]]
name = "rule_matching"
harness = false

[[bench]]
name = "pattern_match"
harness = false

[[bench]]
name = "type_lookup"
harness = false

[[bench]]
name = "prefix_navigation_benchmarks"
harness = false

[[bench]]
name = "bulk_operations"
harness = false

[[bench]]
name = "cow_environment"
harness = false

[[bench]]
name = "algebraic_status_duplicate_detection"
harness = false

[[bench]]
name = "expression_parallelism"
harness = false

[[bench]]
name = "branch_comparison"
harness = false

[[bench]]
name = "mork_evaluation"
harness = false

[dependencies]
# MORK - MeTTa Optimal Reduction Kernel for pattern matching
mork = { path = "../MORK/kernel", features = ["interning"] }
# MORK expr - S-expression representation used by MORK (formerly mork-bytestring)
mork-expr = { path = "../MORK/expr" }
# MORK frontend - Parser for MORK s-expressions
mork-frontend = { path = "../MORK/frontend" }
# MORK interning - Symbol interning for MORK
mork-interning = { path = "../MORK/interning" }
# Models - Rholang protobuf models for PathMap Par integration
models = { path = "../f1r3node/models" }
# Tokio - Async runtime for parallel evaluation (optional)
tokio = { version = "1", features = ["rt", "sync"], optional = true }

# PathMap - Trie-map library used by MORK
# Note: Windows is not currently supported due to jemalloc incompatibility
# MORK's workspace enables jemalloc which requires Unix build tools
pathmap = { path = "../PathMap", features = [
    "jemalloc",
    "arena_compact",
    "viz",
] }
# pathmap = { git = "https://github.com/Adam-Vandervorst/PathMap.git", branch = "master", features = ["jemalloc", "arena_compact"] }
# pathmap = { version = "0.2.0-alpha0", features = ["jemalloc", "arena_compact"] }

# Tree-sitter - Parser for LSP support
tree-sitter = "0.25"
tree-sitter-metta = { path = "tree-sitter-metta" }

# REPL dependencies
rustyline = "14.0"
dirs = "5.0"
regex = "1.11"
ropey = "1.6"

# LRU cache for pattern caching optimization
lru = "0.12"

# SmallVec - Stack-allocated vector for optimizing pattern matching bindings
smallvec = "1.11"

# liblevenshtein - Fuzzy string matching for "Did you mean?" suggestions
# liblevenshtein = { path = "../liblevenshtein-rust", features = ["pathmap-backend"] }
liblevenshtein = { version = "^0.7", features = ["pathmap-backend"] }

tracing = "0.1"
tracing-subscriber = "0.3"

# Note: jemalloc is already enabled globally via PathMap's features = ["jemalloc"]
# PathMap sets tikv-jemallocator as the global allocator, providing 100-1000Ã— parallel speedup

[features]
default = ["interning", "async"]
async = ["tokio"]
interning = []

[dev-dependencies]
# For integration tests
regex = "1.10"
nom = "7.1"
toml = "0.8"
serde = { version = "1.0", features = ["derive"] }
tokio = { version = "1", features = [
    "rt-multi-thread",
    "process",
    "time",
    "sync",
    "macros",
] }
# Benchmarking
criterion = { version = "0.5", features = ["html_reports"] }
divan = "0.1.21"
paste = "1.0.15"
clap = { version = "4.5", features = ["derive"] }

[[bench]]
name = "e2e"
path = "benches/e2e/e2e.rs"
harness = false

[[bench]]
name = "e2e_throughput_configurable"
path = "benches/e2e/e2e_throughput_configurable.rs"
harness = false

[[bench]]
name = "e2e_throughput"
path = "benches/e2e/e2e_throughput.rs"
harness = false

[[bench]]
name = "set_operations"
harness = false

[profile.release]
opt-level = 3
lto = true
codegen-units = 1
strip = true

[profile.bench]
inherits = "release"
strip = false        # Keep debug symbols for profiling
debug = true         # Enable line-level profiling

[profile.profiling]
inherits = "release"
strip = false        # Keep debug symbols for flamegraphs
debug = 1            # Line tables only (smaller than debug = true)

# Debian package metadata
[package.metadata.deb]
maintainer = "F1R3FLY.io <noreply@f1r3fly.io>"
copyright = "2024, F1R3FLY.io <noreply@f1r3fly.io>"
license-file = ["LICENSE", "4"]
extended-description = """\
MeTTaTron is a MeTTa language evaluator with lazy evaluation and pattern matching.
MeTTa is a language with LISP-like S-expression syntax supporting rules, control flow,
type assertions, and grounded functions."""
depends = "$auto"
section = "devel"
priority = "optional"
assets = [
    [
        "target/release/mettatron",
        "usr/bin/",
        "755",
    ],
    [
        "target/release/rholang-cli",
        "usr/bin/",
        "755",
    ],
    [
        "target/release/libmettatron.so",
        "usr/lib/",
        "644",
    ],
    [
        "target/release/libmettatron.rlib",
        "usr/lib/",
        "644",
    ],
    [
        "README.md",
        "usr/share/doc/mettatron/",
        "644",
    ],
    [
        "LICENSE",
        "usr/share/doc/mettatron/",
        "644",
    ],
    [
        "examples/*",
        "usr/share/doc/mettatron/examples/",
        "644",
    ],
]

# RPM package metadata
[package.metadata.generate-rpm]
license = "Apache-2.0"
assets = [
    { source = "target/release/mettatron", dest = "/usr/bin/mettatron", mode = "755" },
    { source = "target/release/rholang-cli", dest = "/usr/bin/rholang-cli", mode = "755" },
    { source = "target/release/libmettatron.so", dest = "/usr/lib64/libmettatron.so", mode = "644" },
    { source = "target/release/libmettatron.rlib", dest = "/usr/lib64/libmettatron.rlib", mode = "644" },
    { source = "README.md", dest = "/usr/share/doc/mettatron/README.md", mode = "644", doc = true },
    { source = "LICENSE", dest = "/usr/share/doc/mettatron/LICENSE", mode = "644", doc = true },
]
